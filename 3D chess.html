<!DOCTYPE html>
<html>
<head>
    <title>Cosmic Chess Engine - No 3D Clock, WebRTC Foundation</title>
    <style>
        body { margin: 0; overflow: hidden; background-image: url('your-park-chess-image.jpg'); background-size: cover; background-position: center center; background-repeat: no-repeat; color: white; font-family: 'Arial', sans-serif; }
        #uiPanel { position: absolute; top: 0; left: 0; width: 100%; padding: 10px 15px; box-sizing: border-box; background-color: rgba(10,10,15,0.85); display: flex; justify-content: space-between; align-items: center; font-size: 1.0em; text-shadow: 0 0 5px #000000; z-index: 80; }
        .timerDisplay { font-weight: bold; color: #F0F0F0; }
        #turnLabel { font-weight: bold; color: #F0F0F0; text-align: center; flex-grow: 1;}
        #messageLabel { color: #87CEFA; text-align: right; min-width: 200px;}
        canvas { display: block; }
        #videoContainer { position: absolute; top: 60px; left: 10px; display: none; flex-direction: column; gap: 5px; z-index: 100; background-color: rgba(0,0,0,0.5); padding: 5px; border-radius: 3px; }
        .videoBox { width: 160px; height: 120px; border: 1px solid #555; background-color: #080808; border-radius: 3px; object-fit: cover; }
        #localVideo { transform: scaleX(-1); }
        #connectionUi { position: absolute; top: 50px; right: 10px; padding: 8px; background-color: rgba(20,20,30,0.85); border-radius: 4px; z-index: 100; display: flex; flex-direction: column; gap: 5px; }
        #connectionUi input, #connectionUi button { margin: 3px; padding: 4px; font-size: 0.9em; }
        #aiTrainerPanel { position:absolute; top:130px; right:10px; background-color:rgba(20,20,30,0.8); padding:8px; border-radius:4px; display:none; text-align:left; z-index: 90; max-width: 200px;}
        #aiTrainerPanel h4 { margin:0 0 5px 0; color:#a0ffa0; font-size: 0.9em;}
        #topMovesList div { margin-bottom: 3px; font-size: 0.85em; color: #ccc;}
        #bottomUiPanel { position: absolute; bottom: 0px; left: 0; width: 100%; padding: 8px 15px; box-sizing: border-box; display: flex; justify-content: space-between; align-items: center; font-size: 0.9em; color: #E0E0E0; background-color: rgba(5,5,10,0.8); z-index: 80; }
        .moveTimerDisplay { font-weight: bold; padding: 5px 10px; background-color: rgba(0,0,0,0.6); border-radius: 3px; min-width: 150px; text-align: center; }
        #retroRadio { display: flex; flex-direction: column; align-items: center; padding: 5px 8px; background-color: rgba(60, 50, 40, 0.85); border: 2px solid #806040; border-radius: 5px; box-shadow: 2px 2px 5px rgba(0,0,0,0.5); }
        #radioScreen { font-size: 0.8em; padding: 4px 10px; background-color: #251C15; color: #FFD700; border: 1px inset #403020; border-radius: 3px; margin-bottom: 5px; min-width: 150px; text-align: center; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        #radioControls button { background-color: #533F2D; color: #E8D8C8; border: 1px solid #705030; border-radius: 3px; padding: 4px 7px; margin: 0 3px; cursor: pointer; font-weight: bold; font-size: 0.9em; }
        #radioControls button:hover { background-color: #684F3A; }
        #radioControls button:active { background-color: #403020; }
    </style>
</head>
<body>
    <div id="uiPanel"> <span id="whiteTimerDisplay" class="timerDisplay">W: 05:00</span> <span id="turnLabel">WHITE'S TURN</span> <span id="blackTimerDisplay" class="timerDisplay">B: 05:00</span> <span id="messageLabel"></span> </div>
    <div id="videoContainer"> <video id="localVideo" class="videoBox" autoplay playsinline muted></video> <video id="remoteVideo" class="videoBox" autoplay playsinline></video> </div>
    <div id="connectionUi"> <input type="text" id="roomIdInput" placeholder="Room ID (if joining)"> <button id="createRoomBtnWebRTC">Create/Join Room</button> <div id="connectionStatus" style="font-size:0.8em; color:#ccc; margin-top:5px;">Status: Disconnected</div> </div>
    <div id="aiTrainerPanel"><h4 >AI Suggestions:</h4><div id="topMovesList"></div></div>
    <div id="bottomUiPanel"> <div id="playerMoveTimerDisplay" class="moveTimerDisplay">Player Move: 00:00</div> <div id="retroRadio"> <div id="radioScreen">Radio Off</div> <div id="radioControls"> <button id="prevTrackBtn">|<</button> <button id="playPauseBtn">>||</button> <button id="nextTrackBtn">>|</button> </div> </div> <div id="aiMoveTimerDisplay" class="moveTimerDisplay">AI Move: 00:00</div> </div>

    <audio id="audioMove" src="sounds/Move.mp3" preload="auto"></audio>
    <audio id="audioCapture" src="sounds/Capture.mp3" preload="auto"></audio>
    <audio id="audioCheck" src="sounds/Check.mp3" preload="auto"></audio>
    <audio id="audioWin" src="sounds/Win.mp3" preload="auto"></audio>
    <audio id="audioLose" src="sounds/Lose.mp3" preload="auto"></audio>
    <audio id="audioStalemate" src="sounds/Stalemate.mp3" preload="auto"></audio>
    <audio id="backgroundMusic" src="sounds/Radio_song1.mp3" loop preload="auto"></audio>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // --- Game Enums/Classes, Constants, State Variables, DOM Elements, Materials ---
        const PieceType={EMPTY:0,PAWN:1,KNIGHT:2,BISHOP:3,ROOK:4,QUEEN:5,KING:6,_length:7};
        const PlayerColor={NONE:0,WHITE:1,BLACK:2,_length:3};
        class Piece{constructor(t,c){this.type=t;this.color=c;this.hasMoved=false;}clone(){const nP=new Piece(this.type,this.color);nP.hasMoved=this.hasMoved;return nP;}}

        let scene,camera,renderer,boardGroup,particlesPoints;
        let pieceMeshes={}; let squareMeshes={};
        const BOARD_LOGIC_SIZE=8;const SQUARE_3D_SIZE=10;const SQUARE_THICKNESS=0.5; const BORDER_WIDTH=SQUARE_3D_SIZE*0.25; const PIECE_BASE_SCALE=SQUARE_3D_SIZE*0.30;const GAME_TIME_SECONDS=5*60;
        const PARTICLE_COUNT = 100;
        let boardLogic=Array(BOARD_LOGIC_SIZE).fill(null).map(()=>Array(BOARD_LOGIC_SIZE).fill(new Piece(PieceType.EMPTY,PlayerColor.NONE)));let currentPlayer=PlayerColor.WHITE;let selectedPieceInfo=null;let isPlayerTurn=true;let timerWhite,timerBlack;let activeTimerSide=null;let gameTimerInterval=null;let isGameOverState=false;

        let turnLabelElement,messageLabelElement,whiteTimerDisplayElement,blackTimerDisplayElement,localVideoElementRTC,remoteVideoElementRTC,roomIdInputRTC,createJoinRoomBtnRTC,connectionStatusRTC,videoContainerRTC, aiTrainerPanelElement, topMovesListElement;
        let playerMoveTimerDisplayElement, aiMoveTimerDisplayElement;
        let radioScreenElement, prevTrackBtnElement, playPauseBtnElement, nextTrackBtnElement, backgroundMusicElement;

        let audioMove, audioCapture, audioCheck, audioWin, audioLose, audioStalemate;

        const radioTracks = [ { name: "Radio Song 1", src: "sounds/Radio_song1.mp3" } ];
        let currentTrackIndex = 0;
        let isRadioPlaying = false;

        let playerMoveTime = 0; let aiMoveTime = 0; let currentMoveTimerInterval = null;

        // WebRTC Variables
        let localStreamRTC;
        let remoteStreamRTC;
        let peerConnectionRTC;
        let isInitiatorRTC = false;
        const rtcConfiguration = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };


        const lightSquareMat=new THREE.MeshStandardMaterial({color:0xCCCCCC,roughness:0.8,metalness:0.1});
        const darkSquareMat=new THREE.MeshStandardMaterial({color:0x505050,roughness:0.8,metalness:0.1});
        const borderMat=new THREE.MeshStandardMaterial({color:0x121212,roughness:0.8,metalness:0.0});
        const whitePieceMat=new THREE.MeshStandardMaterial({color:0xE0E0E0,roughness:0.4,metalness:0.2});
        const blackPieceMat=new THREE.MeshStandardMaterial({color:0x222222,roughness:0.6,metalness:0.1});
        const highlightMat=new THREE.MeshStandardMaterial({color:0x30FF30, emissive: 0x108810, transparent:true, opacity:0.55});
        const validMoveMat=new THREE.MeshStandardMaterial({color:0x60A0FF, emissive: 0x2060AA, transparent:true, opacity:0.4});

        // --- CORE FUNCTIONS (Sound, UI, Timers) ---
        function playSound(audioElement) { if (audioElement) { audioElement.currentTime = 0; const playPromise = audioElement.play(); if (playPromise !== undefined) { playPromise.catch(error => console.warn(`Audio play failed for ${audioElement.id || 'audio'}:`, error)); } } else { console.warn("playSound called with null audioElement"); } }
        function updateTurnLabel(){ turnLabelElement.textContent = `${(currentPlayer === PlayerColor.WHITE ? "WHITE" : "BLACK")}'S TURN`; }
        function setMessage(msg){ if(messageLabelElement) messageLabelElement.textContent = msg; console.log("Message:", msg); }
        function onWindowResize(){ camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
        function formatMoveTime(seconds) { const mins = Math.floor(seconds / 60).toString().padStart(2, '0'); const secs = (seconds % 60).toString().padStart(2, '0'); return `${mins}:${secs}`; }
        function updateMoveTimerDisplay() { if (playerMoveTimerDisplayElement) playerMoveTimerDisplayElement.textContent = `Player Move: ${formatMoveTime(playerMoveTime)}`; if (aiMoveTimerDisplayElement) aiMoveTimerDisplayElement.textContent = `AI Move: ${formatMoveTime(aiMoveTime)}`; }
        function startCurrentMoveTimer(forPlayer) { stopCurrentMoveTimer(); if (forPlayer === PlayerColor.WHITE) { playerMoveTime = 0; } else { aiMoveTime = 0; } updateMoveTimerDisplay(); currentMoveTimerInterval = setInterval(() => { if (forPlayer === PlayerColor.WHITE) { playerMoveTime++; } else { aiMoveTime++; } updateMoveTimerDisplay(); }, 1000); }
        function stopCurrentMoveTimer() { if (currentMoveTimerInterval) clearInterval(currentMoveTimerInterval); currentMoveTimerInterval = null; }
        function updateRadioDisplay() { if (!radioScreenElement || !playPauseBtnElement || !backgroundMusicElement) return; if (isRadioPlaying) { radioScreenElement.textContent = radioTracks[currentTrackIndex].name; playPauseBtnElement.textContent = "||"; } else { radioScreenElement.textContent = "Radio Off"; playPauseBtnElement.textContent = ">"; } }
        function togglePlayPauseRadio() { if (!backgroundMusicElement) return; if (isRadioPlaying) { backgroundMusicElement.pause(); isRadioPlaying = false; } else { const playPromise = backgroundMusicElement.play(); if (playPromise !== undefined) { playPromise.then(_ => { isRadioPlaying = true; updateRadioDisplay(); }).catch(error => { console.warn("Radio play failed:", error); setMessage("Click radio play again."); isRadioPlaying = false; }); } } updateRadioDisplay(); }
        function nextRadioTrack() { if (!backgroundMusicElement || radioTracks.length === 0) return; currentTrackIndex = (currentTrackIndex + 1) % radioTracks.length; backgroundMusicElement.src = radioTracks[currentTrackIndex].src; if (isRadioPlaying) { const playPromise = backgroundMusicElement.play(); if (playPromise !== undefined) { playPromise.catch(error => { console.warn("Next track play failed:", error); isRadioPlaying = false; updateRadioDisplay(); }); } } updateRadioDisplay(); }
        function prevRadioTrack() { if (!backgroundMusicElement || radioTracks.length === 0) return; currentTrackIndex = (currentTrackIndex - 1 + radioTracks.length) % radioTracks.length; backgroundMusicElement.src = radioTracks[currentTrackIndex].src; if (isRadioPlaying) { const playPromise = backgroundMusicElement.play(); if (playPromise !== undefined) { playPromise.catch(error => { console.warn("Prev track play failed:", error); isRadioPlaying = false; updateRadioDisplay(); }); } } updateRadioDisplay(); }

        // --- WebRTC Functions ---
        async function startLocalVideo() {
            try {
                localStreamRTC = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                localVideoElementRTC.srcObject = localStreamRTC;
                videoContainerRTC.style.display = 'flex';
                connectionStatusRTC.textContent = 'Status: Local video started.';
                if (peerConnectionRTC) {
                    localStreamRTC.getTracks().forEach(track => peerConnectionRTC.addTrack(track, localStreamRTC));
                }
            } catch (error) {
                console.error('Error accessing media devices.', error);
                connectionStatusRTC.textContent = 'Status: Error accessing camera/mic.';
                setMessage('Could not access camera/microphone.');
            }
        }

        function createPeerConnection() {
            if (peerConnectionRTC) { peerConnectionRTC.close(); }
            peerConnectionRTC = new RTCPeerConnection(rtcConfiguration);
            connectionStatusRTC.textContent = 'Status: Peer connection created.';
            peerConnectionRTC.onicecandidate = handleICECandidateEventRTC;
            peerConnectionRTC.ontrack = handleTrackEventRTC;
            peerConnectionRTC.onnegotiationneeded = handleNegotiationNeededEventRTC;
            if (localStreamRTC) {
                localStreamRTC.getTracks().forEach(track => peerConnectionRTC.addTrack(track, localStreamRTC));
            }
        }

        async function handleNegotiationNeededEventRTC() {
            console.log('Negotiation needed event fired.');
            if (isInitiatorRTC) {
                try {
                    console.log('Creating offer...');
                    connectionStatusRTC.textContent = 'Status: Creating offer...';
                    const offer = await peerConnectionRTC.createOffer();
                    await peerConnectionRTC.setLocalDescription(offer);
                    console.log('Offer created. Send via console/signaling:');
                    console.log(JSON.stringify({ sdp: peerConnectionRTC.localDescription }));
                    connectionStatusRTC.textContent = 'Status: Offer created. Copy from console.';
                } catch (error) {
                    console.error('Error creating offer:', error);
                    connectionStatusRTC.textContent = 'Status: Error creating offer.';
                }
            }
        }

        function handleICECandidateEventRTC(event) {
            if (event.candidate) {
                console.log('ICE candidate. Send via console/signaling:');
                console.log(JSON.stringify({ ice: event.candidate }));
                connectionStatusRTC.textContent = 'Status: ICE candidate. Copy from console.';
            }
        }

        function handleTrackEventRTC(event) {
            console.log('Track event received.');
            if (event.streams && event.streams[0]) {
                remoteVideoElementRTC.srcObject = event.streams[0];
                remoteStreamRTC = event.streams[0];
                connectionStatusRTC.textContent = 'Status: Remote stream received.';
            } else {
                if (!remoteStreamRTC) {
                    remoteStreamRTC = new MediaStream();
                    remoteVideoElementRTC.srcObject = remoteStreamRTC;
                }
                remoteStreamRTC.addTrack(event.track);
            }
        }

        async function handleSignalingDataInput(dataString) {
            if (!peerConnectionRTC) {
                console.warn("PeerConnection not initialized. Click 'Create/Join Room' first.");
                setMessage("Initialize connection first (Create/Join Room).");
                return;
            }
            try {
                const data = JSON.parse(dataString);
                if (data.sdp) {
                    connectionStatusRTC.textContent = 'Status: Received SDP...';
                    console.log('Received SDP:', data.sdp);
                    await peerConnectionRTC.setRemoteDescription(new RTCSessionDescription(data.sdp));
                    console.log('Remote description set.');
                    if (data.sdp.type === 'offer' && !isInitiatorRTC) {
                        console.log('Creating answer...');
                        connectionStatusRTC.textContent = 'Status: Creating answer...';
                        const answer = await peerConnectionRTC.createAnswer();
                        await peerConnectionRTC.setLocalDescription(answer);
                        console.log('Answer created. Send via console/signaling:');
                        console.log(JSON.stringify({ sdp: peerConnectionRTC.localDescription }));
                        connectionStatusRTC.textContent = 'Status: Answer created. Copy from console.';
                    }
                } else if (data.ice) {
                    connectionStatusRTC.textContent = 'Status: Received ICE candidate...';
                    console.log('Received ICE candidate:', data.ice);
                    await peerConnectionRTC.addIceCandidate(new RTCIceCandidate(data.ice));
                    console.log('ICE candidate added.');
                    connectionStatusRTC.textContent = 'Status: ICE candidate added.';
                }
            } catch (error) {
                console.error('Error handling signaling data:', error);
                connectionStatusRTC.textContent = 'Status: Error in signaling data.';
            }
        }

        async function setupAndJoinOrCreateRoom(){
            const roomId = roomIdInputRTC.value.trim();
            isInitiatorRTC = (roomId === '');

            if (!localStreamRTC) {
                await startLocalVideo();
                if (!localStreamRTC) {
                    setMessage("Cannot proceed without local video.");
                    return;
                }
            }
            createPeerConnection();
            if (isInitiatorRTC) {
                console.log("Acting as initiator.");
                connectionStatusRTC.textContent = 'Status: Initiator. Waiting for negotiation...';
            } else {
                console.log(`Attempting to join room (conceptually): ${roomId}`);
                connectionStatusRTC.textContent = `Status: Joining room ${roomId}. Waiting for offer...`;
            }
        }

        // --- INITIALIZATION ---
        function init() {
            console.log("Initializing Cosmic Chess Engine - No 3D Clock, WebRTC Foundation...");

            turnLabelElement = document.getElementById('turnLabel');
            messageLabelElement = document.getElementById('messageLabel');
            whiteTimerDisplayElement = document.getElementById('whiteTimerDisplay');
            blackTimerDisplayElement = document.getElementById('blackTimerDisplay');
            localVideoElementRTC = document.getElementById('localVideo');
            remoteVideoElementRTC = document.getElementById('remoteVideo');
            roomIdInputRTC = document.getElementById('roomIdInput');
            createJoinRoomBtnRTC = document.getElementById('createRoomBtnWebRTC');
            connectionStatusRTC = document.getElementById('connectionStatus');
            videoContainerRTC = document.getElementById('videoContainer');
            aiTrainerPanelElement = document.getElementById('aiTrainerPanel');
            topMovesListElement = document.getElementById('topMovesList');
            playerMoveTimerDisplayElement = document.getElementById('playerMoveTimerDisplay');
            aiMoveTimerDisplayElement = document.getElementById('aiMoveTimerDisplay');
            radioScreenElement = document.getElementById('radioScreen');
            prevTrackBtnElement = document.getElementById('prevTrackBtn');
            playPauseBtnElement = document.getElementById('playPauseBtn');
            nextTrackBtnElement = document.getElementById('nextTrackBtn');
            backgroundMusicElement = document.getElementById('backgroundMusic');

            if (createJoinRoomBtnRTC) { createJoinRoomBtnRTC.addEventListener('click', setupAndJoinOrCreateRoom); }
            audioMove = document.getElementById('audioMove');
            audioCapture = document.getElementById('audioCapture');
            audioCheck = document.getElementById('audioCheck');
            audioWin = document.getElementById('audioWin');
            audioLose = document.getElementById('audioLose');
            audioStalemate = document.getElementById('audioStalemate');
            if (prevTrackBtnElement) { prevTrackBtnElement.addEventListener('click', prevRadioTrack); }
            if (playPauseBtnElement) { playPauseBtnElement.addEventListener('click', togglePlayPauseRadio); }
            if (nextTrackBtnElement) { nextTrackBtnElement.addEventListener('click', nextRadioTrack); }
            updateRadioDisplay();

            scene = new THREE.Scene();
            const aspectRatio = window.innerWidth / window.innerHeight;
            camera = new THREE.PerspectiveCamera(38, aspectRatio, 5, 6000);
            camera.position.set(0, SQUARE_3D_SIZE * 9.5, SQUARE_3D_SIZE * 9);
            camera.lookAt(0, -SQUARE_3D_SIZE * 1, 0);
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            setupLighting();
            boardGroup = new THREE.Group();
            scene.add(boardGroup);
            if (PARTICLE_COUNT > 0) { createParticles(PARTICLE_COUNT); }
            initializeBoardLogicStandard();
            create3DBoardAndBorder();
            refresh3DPieceDisplay();
            initializeTimers();
            updateMoveTimerDisplay();

            setTimeout(() => {
                updateDigitalClocks();
                if (!isGameOverState) {
                    startPlayerTimer(PlayerColor.WHITE);
                    startCurrentMoveTimer(PlayerColor.WHITE);
                }
            }, 200);

            updateTurnLabel();
            window.addEventListener('resize', onWindowResize, false);
            renderer.domElement.addEventListener('mousedown', onBoardClick, false);
            console.log("Initialization sequence complete.");
            animate();
        }

        // --- 3D SETUP AND RENDERING FUNCTIONS ---
        function setupLighting() { const ambientLight=new THREE.AmbientLight(0x707070);scene.add(ambientLight);const keyLight=new THREE.DirectionalLight(0xffffff,0.8);keyLight.position.set(-60,100,50);keyLight.castShadow=true;keyLight.shadow.mapSize.width=2048;keyLight.shadow.mapSize.height=2048;const dS=SQUARE_3D_SIZE*BOARD_LOGIC_SIZE;keyLight.shadow.camera.left=-dS;keyLight.shadow.camera.right=dS;keyLight.shadow.camera.top=dS;keyLight.shadow.camera.bottom=-dS;keyLight.shadow.camera.near=30;keyLight.shadow.camera.far=280;keyLight.shadow.bias=-0.0004;scene.add(keyLight);const fillLight=new THREE.DirectionalLight(0x9090A0,0.35);fillLight.position.set(60,70,-40);scene.add(fillLight); }
        function create3DBoardAndBorder(){ const squareGeo=new THREE.BoxGeometry(SQUARE_3D_SIZE,SQUARE_THICKNESS,SQUARE_3D_SIZE);for(let r=0;r<BOARD_LOGIC_SIZE;r++){for(let c=0;c<BOARD_LOGIC_SIZE;c++){const currentSquareMat=((r+c)%2===0?lightSquareMat.clone():darkSquareMat.clone());const squareMesh=new THREE.Mesh(squareGeo,currentSquareMat);squareMesh.position.set((c-(BOARD_LOGIC_SIZE-1)/2.0)*SQUARE_3D_SIZE,-SQUARE_THICKNESS/2.0,(r-(BOARD_LOGIC_SIZE-1)/2.0)*SQUARE_3D_SIZE);squareMesh.receiveShadow=true;squareMesh.userData={type:'square',row:r,col:c,originalMat:currentSquareMat};boardGroup.add(squareMesh);squareMeshes[`r${r}c${c}`]=squareMesh;}}const boardPlayingAreaSize=BOARD_LOGIC_SIZE*SQUARE_3D_SIZE;const borderOuterSize=boardPlayingAreaSize+2*BORDER_WIDTH;const borderGeo=new THREE.BoxGeometry(borderOuterSize,SQUARE_THICKNESS,borderOuterSize);const borderMesh=new THREE.Mesh(borderGeo,borderMat);borderMesh.position.y=-SQUARE_THICKNESS/2.0-0.02; borderMesh.receiveShadow=true;boardGroup.add(borderMesh);}
        function createPieceMesh(pieceLogic){ const material=(pieceLogic.color===PlayerColor.WHITE?whitePieceMat.clone():blackPieceMat.clone());const pieceGroup=new THREE.Group();const R=PIECE_BASE_SCALE;const H_SEG=PIECE_BASE_SCALE*0.45;let mainBody,head,topFeature;switch(pieceLogic.type){case PieceType.PAWN:mainBody=new THREE.Mesh(new THREE.CylinderGeometry(R*0.55,R*0.65,H_SEG*1.8,12),material);mainBody.position.y=H_SEG*0.9;head=new THREE.Mesh(new THREE.SphereGeometry(R*0.5,12,8),material);head.position.y=H_SEG*1.8+R*0.45;pieceGroup.add(mainBody,head);break;case PieceType.ROOK:mainBody=new THREE.Mesh(new THREE.CylinderGeometry(R*0.7,R*0.7,H_SEG*2.8,12),material);mainBody.position.y=H_SEG*1.4;topFeature=new THREE.Mesh(new THREE.CylinderGeometry(R*0.85,R*0.85,H_SEG*0.7,12),material);topFeature.position.y=H_SEG*2.8+H_SEG*0.35;pieceGroup.add(mainBody,topFeature);break;case PieceType.KNIGHT:const knightBaseG=new THREE.Mesh(new THREE.CylinderGeometry(R*0.7,R*0.8,H_SEG*1.2,12),material);knightBaseG.position.y=H_SEG*0.6;mainBody=new THREE.Mesh(new THREE.BoxGeometry(R*1.0,H_SEG*1.8,R*0.55),material);mainBody.position.y=H_SEG*1.2+H_SEG*0.9;mainBody.rotation.y=Math.PI/16;head=new THREE.Mesh(new THREE.SphereGeometry(R*0.45,12,8),material);head.scale.set(1.1,1.3,0.9);head.position.y=mainBody.position.y+H_SEG*0.9;head.position.x=R*0.35;head.rotation.z=-Math.PI/7;pieceGroup.add(knightBaseG,mainBody,head);break;case PieceType.BISHOP:mainBody=new THREE.Mesh(new THREE.CylinderGeometry(R*0.5,R*0.7,H_SEG*2.8,12),material);mainBody.position.y=H_SEG*1.4;head=new THREE.Mesh(new THREE.SphereGeometry(R*0.6,12,8),material);head.position.y=H_SEG*2.8+R*0.5;topFeature=new THREE.Mesh(new THREE.SphereGeometry(R*0.2,8,6),material);topFeature.position.y=head.position.y+R*0.55;topFeature.scale.y=1.6;pieceGroup.add(mainBody,head,topFeature);break;case PieceType.QUEEN:mainBody=new THREE.Mesh(new THREE.CylinderGeometry(R*0.6,R*0.8,H_SEG*3.0,12),material);mainBody.position.y=H_SEG*1.5;head=new THREE.Mesh(new THREE.SphereGeometry(R*0.65,12,8),material);head.position.y=H_SEG*3.0+R*0.55;for(let i=0;i<6;i++){const point=new THREE.Mesh(new THREE.ConeGeometry(R*0.1,H_SEG*0.6,6),material);point.position.y=head.position.y+R*0.3+H_SEG*0.3;const angle=i*Math.PI*2/6;point.position.x=Math.cos(angle)*R*0.5;point.position.z=Math.sin(angle)*R*0.5;point.rotation.x=Math.PI/16;pieceGroup.add(point);}pieceGroup.add(mainBody,head);break;case PieceType.KING:mainBody=new THREE.Mesh(new THREE.CylinderGeometry(R*0.7,R*0.9,H_SEG*3.3,12),material);mainBody.position.y=H_SEG*1.65;const crossBase=new THREE.Mesh(new THREE.CylinderGeometry(R*0.3,R*0.3,H_SEG*0.3,8),material);crossBase.position.y=H_SEG*3.3+H_SEG*0.15;topFeature=new THREE.Mesh(new THREE.BoxGeometry(R*0.12,H_SEG*0.6,R*0.12),material);topFeature.position.y=crossBase.position.y+H_SEG*0.3+H_SEG*0.3;const crossArm=new THREE.Mesh(new THREE.BoxGeometry(H_SEG*0.5,R*0.12,R*0.12),material);crossArm.position.y=topFeature.position.y-H_SEG*0.05;pieceGroup.add(mainBody,crossBase,topFeature,crossArm);break;default: const errGeo=new THREE.BoxGeometry(R,R,R); const errMesh = new THREE.Mesh(errGeo, new THREE.MeshBasicMaterial({color:0xff0000})); pieceGroup.add(errMesh); break;} return pieceGroup;}
        function createParticles(count){if(count===0){return;}const positions=[];const particleMaterial=new THREE.PointsMaterial({color:0xffffff,size:0.07,sizeAttenuation:true,transparent:true,opacity:0.4,blending:THREE.AdditiveBlending,depthWrite:false});const particleAnimationSpread=SQUARE_3D_SIZE*BOARD_LOGIC_SIZE*3.0; const particleZResetMax=SQUARE_3D_SIZE*(BOARD_LOGIC_SIZE*0.5+2)+3000; const particleZResetMin=SQUARE_3D_SIZE*(BOARD_LOGIC_SIZE*0.5+2)+200; for(let i=0;i<count;i++){const x=(Math.random()-0.5)*particleAnimationSpread;const y=(Math.random()-0.5)*particleAnimationSpread*0.6;const z=particleZResetMin+Math.random()*(particleZResetMax-particleZResetMin);positions.push(x,y,z);}const particleGeometry=new THREE.BufferGeometry();particleGeometry.setAttribute('position',new THREE.Float32BufferAttribute(positions,3));particlesPoints=new THREE.Points(particleGeometry,particleMaterial);scene.add(particlesPoints);}

        // --- CHESS LOGIC FUNCTIONS ---
        function initializeBoardLogicStandard(){ for(let r=0; r<BOARD_LOGIC_SIZE; r++) for(let c=0; c<BOARD_LOGIC_SIZE; c++) boardLogic[r][c] = new Piece(PieceType.EMPTY, PlayerColor.NONE); const P = PieceType, C = PlayerColor; boardLogic[0][0]=new Piece(P.ROOK,C.BLACK); boardLogic[0][1]=new Piece(P.KNIGHT,C.BLACK); boardLogic[0][2]=new Piece(P.BISHOP,C.BLACK); boardLogic[0][3]=new Piece(P.QUEEN,C.BLACK); boardLogic[0][4]=new Piece(P.KING,C.BLACK); boardLogic[0][5]=new Piece(P.BISHOP,C.BLACK); boardLogic[0][6]=new Piece(P.KNIGHT,C.BLACK); boardLogic[0][7]=new Piece(P.ROOK,C.BLACK); for(let c=0;c<8;c++) boardLogic[1][c]=new Piece(P.PAWN,C.BLACK); for(let c=0;c<8;c++) boardLogic[6][c]=new Piece(P.PAWN,C.WHITE); boardLogic[7][0]=new Piece(P.ROOK,C.WHITE); boardLogic[7][1]=new Piece(P.KNIGHT,C.WHITE); boardLogic[7][2]=new Piece(P.BISHOP,C.WHITE); boardLogic[7][3]=new Piece(P.QUEEN,C.WHITE); boardLogic[7][4]=new Piece(P.KING,C.WHITE); boardLogic[7][5]=new Piece(P.BISHOP,C.WHITE); boardLogic[7][6]=new Piece(P.KNIGHT,C.WHITE); boardLogic[7][7]=new Piece(P.ROOK,C.WHITE); currentPlayer = C.WHITE;}
        function getOpponent(player){return player===PlayerColor.WHITE?PlayerColor.BLACK:PlayerColor.WHITE;}
        function isPathClear(startR,startC,endR,endC,boardState=boardLogic){const stepR=Math.sign(endR-startR);const stepC=Math.sign(endC-startC);let currentR=startR+stepR;let currentC=startC+stepC;while(currentR!==endR||currentC!==endC){if(boardState[currentR][currentC].type!==PieceType.EMPTY)return false;currentR+=stepR;currentC+=stepC;}return true;}
        function isValidMove(startR,startC,endR,endC,piece,playerColor,boardState=boardLogic,checkKingSafety=true){if(!piece || piece.type === PieceType.EMPTY) return false; if(startR<0||startR>=BOARD_LOGIC_SIZE||startC<0||startC>=BOARD_LOGIC_SIZE||endR<0||endR>=BOARD_LOGIC_SIZE||endC<0||endC>=BOARD_LOGIC_SIZE)return false;if(startR===endR&&startC===endC)return false;const targetPiece=boardState[endR][endC];if(targetPiece.type!==PieceType.EMPTY&&targetPiece.color===playerColor)return false;const dR=endR-startR;const dC=endC-startC;let validBasicMove=false;switch(piece.type){case PieceType.PAWN:const dir=(playerColor===PlayerColor.WHITE)?-1:1;if(dC===0&&dR===dir&&targetPiece.type===PieceType.EMPTY)validBasicMove=true;if(dC===0&&dR===2*dir&&targetPiece.type===PieceType.EMPTY&&!piece.hasMoved&&boardState[startR+dir][startC].type===PieceType.EMPTY)validBasicMove=true;if(Math.abs(dC)===1&&dR===dir&&targetPiece.type!==PieceType.EMPTY&&targetPiece.color!==playerColor)validBasicMove=true;break;case PieceType.ROOK:if(dR===0||dC===0)validBasicMove=isPathClear(startR,startC,endR,endC,boardState);break;case PieceType.BISHOP:if(Math.abs(dR)===Math.abs(dC))validBasicMove=isPathClear(startR,startC,endR,endC,boardState);break;case PieceType.QUEEN:if(dR===0||dC===0||Math.abs(dR)===Math.abs(dC))validBasicMove=isPathClear(startR,startC,endR,endC,boardState);break;case PieceType.KING:validBasicMove=(Math.abs(dR)<=1&&Math.abs(dC)<=1);break;case PieceType.KNIGHT:validBasicMove=((Math.abs(dR)===2&&Math.abs(dC)===1)||(Math.abs(dR)===1&&Math.abs(dC)===2));break;default:return false;}if(!validBasicMove)return false;if(checkKingSafety){const tempBoard=applyMoveToBoardCopy(boardState,{start:{row:startR,col:startC},end:{row:endR,col:endC}});if(isKingInCheck(tempBoard,playerColor))return false;}return true;}
        function refresh3DPieceDisplay(highlightingMoves = false){if (!highlightingMoves) { Object.values(pieceMeshes).forEach(meshGroup=>{ if(meshGroup.parent) meshGroup.parent.remove(meshGroup); meshGroup.traverse(child=>{if(child.isMesh){if(child.geometry)child.geometry.dispose();if(child.material){if(Array.isArray(child.material)){child.material.forEach(mat=>mat.dispose());}else{child.material.dispose();}}}}); });pieceMeshes={};for(let r=0;r<BOARD_LOGIC_SIZE;r++){for(let c=0;c<BOARD_LOGIC_SIZE;c++){const pL=boardLogic[r][c];if(pL.type!==PieceType.EMPTY){const p3DG=createPieceMesh(pL);if(p3DG){p3DG.position.set((c-(BOARD_LOGIC_SIZE-1)/2.0)*SQUARE_3D_SIZE,0.01,(r-(BOARD_LOGIC_SIZE-1)/2.0)*SQUARE_3D_SIZE);p3DG.userData={type:'piece',row:r,col:c,piece:pL};p3DG.traverse(ch=>{if(ch.isMesh){ch.castShadow=true;ch.receiveShadow=true;}});boardGroup.add(p3DG);pieceMeshes[`r${r}c${c}`]=p3DG;} }}}}Object.values(squareMeshes).forEach(sq=>{ if(sq.userData.originalMat) sq.material = sq.userData.originalMat.clone(); });if(selectedPieceInfo && selectedPieceInfo.pieceLogic && squareMeshes[`r${selectedPieceInfo.row}c${selectedPieceInfo.col}`]){squareMeshes[`r${selectedPieceInfo.row}c${selectedPieceInfo.col}`].material = highlightMat.clone();const piece = selectedPieceInfo.pieceLogic; const rStart = selectedPieceInfo.row; const cStart = selectedPieceInfo.col;for (let rEnd = 0; rEnd < BOARD_LOGIC_SIZE; rEnd++) {for (let cEnd = 0; cEnd < BOARD_LOGIC_SIZE; cEnd++) {if (isValidMove(rStart, cStart, rEnd, cEnd, piece, currentPlayer, boardLogic, true)) {const squareKey = `r${rEnd}c${cEnd}`;if (squareMeshes[squareKey] && squareMeshes[squareKey] !== squareMeshes[`r${selectedPieceInfo.row}c${selectedPieceInfo.col}`]) {squareMeshes[squareKey].material = validMoveMat.clone();}}}}}}

        // --- GAME MANAGEMENT FUNCTIONS ---
        function makeMoveLogic(startR,startC,endR,endC){const movingPiece=boardLogic[startR][startC].clone();const originalTargetPiece = boardLogic[endR][endC].clone();if(movingPiece.type===PieceType.PAWN){if((movingPiece.color===PlayerColor.WHITE&&endR===0)||(movingPiece.color===PlayerColor.BLACK&&endR===BOARD_LOGIC_SIZE-1)){movingPiece.type=PieceType.QUEEN;setMessage("Pawn promoted!");}}boardLogic[endR][endC]=movingPiece;boardLogic[startR][startC]=new Piece(PieceType.EMPTY,PlayerColor.NONE);boardLogic[endR][endC].hasMoved=true;if (originalTargetPiece.type !== PieceType.EMPTY) {playSound(audioCapture);} else {playSound(audioMove);}}
        function switchPlayer(){stopCurrentMoveTimer();currentPlayer=getOpponent(currentPlayer);updateTurnLabel();isPlayerTurn=(currentPlayer===PlayerColor.WHITE);if(isGameOverState)isPlayerTurn=false;else startCurrentMoveTimer(currentPlayer);}
        function isKingCaptured(boardState,kingColor){for(let r=0;r<BOARD_LOGIC_SIZE;r++)for(let c=0;c<BOARD_LOGIC_SIZE;c++)if(boardState[r][c].type===PieceType.KING&&boardState[r][c].color===kingColor)return false;return true;}
        function initializeTimers(){timerWhite=GAME_TIME_SECONDS;timerBlack=GAME_TIME_SECONDS;activeTimerSide=null;isGameOverState=false;updateDigitalClocks();updateTurnLabel();}
        function formatTime(totalSeconds){const minutes=Math.floor(totalSeconds/60);const seconds=totalSeconds%60;return`${minutes.toString().padStart(2,'0')}:${seconds.toString().padStart(2,'0')}`;}
        function updateDigitalClocks(){const whiteTimeStr=formatTime(Math.max(0,timerWhite));const blackTimeStr=formatTime(Math.max(0,timerBlack));if(whiteTimerDisplayElement)whiteTimerDisplayElement.textContent=`W: ${whiteTimeStr}`;if(blackTimerDisplayElement)blackTimerDisplayElement.textContent=`B: ${blackTimeStr}`;}
        function startPlayerTimer(playerColor){if(isGameOverState)return;if(gameTimerInterval)clearInterval(gameTimerInterval);activeTimerSide=playerColor;gameTimerInterval=setInterval(()=>{if(isGameOverState){clearInterval(gameTimerInterval);return;}if(activeTimerSide===PlayerColor.WHITE){timerWhite--;if(timerWhite<0){timerWhite=0;clearInterval(gameTimerInterval);setMessage("WHITE's time is up! BLACK wins!");isGameOverState=true;isPlayerTurn=false; playSound(audioLose);}}else if(activeTimerSide===PlayerColor.BLACK){timerBlack--;if(timerBlack<0){timerBlack=0;clearInterval(gameTimerInterval);setMessage("BLACK's time is up! WHITE wins!");isGameOverState=true;isPlayerTurn=false; playSound(audioWin);}}updateDigitalClocks();},1000);}
        function stopPlayerTimer(){if(gameTimerInterval)clearInterval(gameTimerInterval);activeTimerSide=null;}
        function pressClockButton(playerWhoJustMoved) {if(isGameOverState){stopPlayerTimer();return;}stopPlayerTimer();const nextPlayerToStartTimer=getOpponent(playerWhoJustMoved);startPlayerTimer(nextPlayerToStartTimer);updateDigitalClocks();}

        function onBoardClick(event){
            if(isGameOverState || !isPlayerTurn ){ return; } // Player can only interact if it's their turn
            event.preventDefault(); setMessage("");
            const mouse=new THREE.Vector2((event.clientX/renderer.domElement.clientWidth)*2-1,-(event.clientY/renderer.domElement.clientHeight)*2+1);
            const raycaster=new THREE.Raycaster(); raycaster.setFromCamera(mouse,camera);
            const intersectableObjects = [...boardGroup.children]; // Removed clockGroup from intersectables
            const intersects=raycaster.intersectObjects(intersectableObjects,true);

            if (intersects.length > 0) {
                let clickedUserData = null;
                for (let i = 0; i < intersects.length; i++) {
                    let obj = intersects[i].object;
                    while (obj.parent && obj.parent !== scene && !(obj.userData && obj.userData.type)) { obj = obj.parent; }
                    // Only consider squares and pieces, no clockButton
                    if (obj.userData && (obj.userData.type === 'square' || obj.userData.type === 'piece')) {
                        clickedUserData = obj.userData; break;
                    }
                }

                if (clickedUserData) {
                    // Removed direct clock button interaction logic
                    if (currentPlayer !== PlayerColor.WHITE || !isPlayerTurn) {
                        setMessage("Wait for your turn or AI move.");
                        return;
                    }

                    const r = clickedUserData.row; const c = clickedUserData.col;
                    if (selectedPieceInfo === null) {
                        if (boardLogic[r][c].type !== PieceType.EMPTY && boardLogic[r][c].color === currentPlayer) {
                            selectedPieceInfo = { pieceLogic: boardLogic[r][c], row: r, col: c };
                            refresh3DPieceDisplay(true);
                        } else if (boardLogic[r][c].type !== PieceType.EMPTY) {
                            setMessage("Not your piece!"); refresh3DPieceDisplay();
                        } else {
                            refresh3DPieceDisplay();
                        }
                    } else {
                        if (isValidMove(selectedPieceInfo.row, selectedPieceInfo.col, r, c, selectedPieceInfo.pieceLogic, currentPlayer, boardLogic, true)) {
                            const playerWhoMoved = currentPlayer;
                            makeMoveLogic(selectedPieceInfo.row, selectedPieceInfo.col, r, c);
                            const opponentColor = getOpponent(currentPlayer);
                            if (isKingInCheck(boardLogic, opponentColor)) { playSound(audioCheck); setMessage("Check!"); }
                            if (isKingCaptured(boardLogic, opponentColor)) {
                                setMessage((Object.keys(PlayerColor).find(k => PlayerColor[k] === currentPlayer) || "Player") + " WINS!");
                                isGameOverState = true; isPlayerTurn = false; stopPlayerTimer(); stopCurrentMoveTimer(); updateDigitalClocks();
                                if (currentPlayer === PlayerColor.WHITE) playSound(audioWin); else playSound(audioLose);
                                selectedPieceInfo = null; refresh3DPieceDisplay(); return;
                            }
                            if (isGameOver(boardLogic, opponentColor)) {
                                isGameOverState = true; isPlayerTurn = false; stopPlayerTimer(); stopCurrentMoveTimer(); updateDigitalClocks();
                                selectedPieceInfo = null; refresh3DPieceDisplay(); return;
                            }
                            switchPlayer();
                            pressClockButton(playerWhoMoved);
                            selectedPieceInfo = null;
                            refresh3DPieceDisplay();
                            if (currentPlayer === PlayerColor.BLACK && !isGameOverState) {
                                makeAIMove();
                            }
                        } else {
                            if (boardLogic[r][c].type !== PieceType.EMPTY && boardLogic[r][c].color === currentPlayer) {
                                selectedPieceInfo = { pieceLogic: boardLogic[r][c], row: r, col: c };
                                refresh3DPieceDisplay(true);
                            } else {
                                setMessage("Invalid move for " + (Object.keys(PieceType).find(k => PieceType[k] === selectedPieceInfo.pieceLogic.type) || "Piece"));
                                selectedPieceInfo = null; refresh3DPieceDisplay();
                            }
                        }
                    }
                }
            } else {
                selectedPieceInfo = null; refresh3DPieceDisplay();
            }
        }

        // --- AI LOGIC ---
        const AI_SEARCH_DEPTH = 2;
        const pieceValues = { [PieceType.PAWN]: 100, [PieceType.KNIGHT]: 320, [PieceType.BISHOP]: 330, [PieceType.ROOK]: 500, [PieceType.QUEEN]: 900, [PieceType.KING]: 20000 };
        const pawnTable = [[0,0,0,0,0,0,0,0],[50,50,50,50,50,50,50,50],[10,10,20,30,30,20,10,10],[5,5,10,25,25,10,5,5],[0,0,0,20,20,0,0,0],[5,-5,-10,0,0,-10,-5,5],[5,10,10,-20,-20,10,10,5],[0,0,0,0,0,0,0,0]];
        function evaluateBoard(board){let score=0;for(let r=0;r<BOARD_LOGIC_SIZE;r++){for(let c=0;c<BOARD_LOGIC_SIZE;c++){const piece=board[r][c];if(piece.type!==PieceType.EMPTY){let value=pieceValues[piece.type]||0;if(piece.type===PieceType.PAWN){value+=(piece.color===PlayerColor.WHITE)?pawnTable[r][c]:pawnTable[7-r][c];}if(piece.color===PlayerColor.WHITE){score+=value;}else{score-=value;}}}}return score;}
        function generateAllPossibleMoves(currentBoard,player){const moves=[];for(let r=0;r<BOARD_LOGIC_SIZE;r++){for(let c=0;c<BOARD_LOGIC_SIZE;c++){if(currentBoard[r][c].color===player){const piece = currentBoard[r][c]; if(piece.type === PieceType.EMPTY) continue; for(let tr=0;tr<BOARD_LOGIC_SIZE;tr++){for(let tc=0;tc<BOARD_LOGIC_SIZE;tc++){if(isValidMove(r,c,tr,tc,piece,player,currentBoard,false)){const tempBoardAfterMove=applyMoveToBoardCopy(currentBoard,{start:{row:r,col:c},end:{row:tr,col:tc}});if(!isKingInCheck(tempBoardAfterMove,player)){moves.push({start:{row:r,col:c},end:{row:tr,col:tc}});}}}}}}}return moves;}
        function applyMoveToBoardCopy(originalBoard,move){const newBoard=originalBoard.map(row=>row.map(p=>p.clone()));const pieceToMove=newBoard[move.start.row][move.start.col];if(pieceToMove.type===PieceType.PAWN){if((pieceToMove.color===PlayerColor.WHITE&&move.end.row===0)||(pieceToMove.color===PlayerColor.BLACK&&move.end.row===BOARD_LOGIC_SIZE-1)){pieceToMove.type=PieceType.QUEEN;}}newBoard[move.end.row][move.end.col]=pieceToMove;newBoard[move.start.row][move.start.col]=new Piece(PieceType.EMPTY,PlayerColor.NONE);if(newBoard[move.end.row][move.end.col].type!==PieceType.EMPTY){newBoard[move.end.row][move.end.col].hasMoved=true;}return newBoard;}
        function isKingInCheck(boardState,playerColor){let kingR=-1,kingC=-1;for(let r=0;r<BOARD_LOGIC_SIZE;r++){for(let c=0;c<BOARD_LOGIC_SIZE;c++){if(boardState[r][c].type===PieceType.KING&&boardState[r][c].color===playerColor){kingR=r;kingC=c;break;}}if(kingR===-1)return true;}const opponentColor=getOpponent(playerColor);for(let r=0;r<BOARD_LOGIC_SIZE;r++){for(let c=0;c<BOARD_LOGIC_SIZE;c++){const piece=boardState[r][c];if(piece.color===opponentColor && piece.type !== PieceType.EMPTY){if(isValidMove(r,c,kingR,kingC,piece,opponentColor,boardState,false)){return true;}}}}return false;}
        function isGameOver(boardState,playerToMove){const possibleMoves=generateAllPossibleMoves(boardState,playerToMove);if(possibleMoves.length===0){if(isKingInCheck(boardState,playerToMove)){const winnerName=Object.keys(PlayerColor).find(k=>PlayerColor[k]===getOpponent(playerToMove))||"Opponent";setMessage(winnerName+" WINS by Checkmate!");if(getOpponent(playerToMove)===PlayerColor.WHITE) playSound(audioWin); else playSound(audioLose);return true;}else{setMessage("STALEMATE!");playSound(audioStalemate);return true;}}return false;}
        function minimax(board,depth,player,alpha,beta,isMaximizingWhite){if(depth===0||isGameOver(board,player)){return evaluateBoard(board);}const possibleMoves=generateAllPossibleMoves(board,player);if(possibleMoves.length===0){return isKingInCheck(board,player)?(isMaximizingWhite?-Infinity:Infinity):0;}if(isMaximizingWhite){let maxEval=-Infinity;for(const move of possibleMoves){const tempBoard=applyMoveToBoardCopy(board,move);const currentEval=minimax(tempBoard,depth-1,getOpponent(player),alpha,beta,false);maxEval=Math.max(maxEval,currentEval);alpha=Math.max(alpha,currentEval);if(beta<=alpha)break;}return maxEval;}else{let minEval=Infinity;for(const move of possibleMoves){const tempBoard=applyMoveToBoardCopy(board,move);const currentEval=minimax(tempBoard,depth-1,getOpponent(player),alpha,beta,true);minEval=Math.min(minEval,currentEval);beta=Math.min(beta,currentEval);if(beta<=alpha)break;}return minEval;}}
        function findBestMoveMinimax(currentBoardState,player,depth){let bestMove=null;let bestScore;const possibleMoves=generateAllPossibleMoves(currentBoardState,player);if(possibleMoves.length===0){return null;}let topMovesForDisplay = [];if(player===PlayerColor.WHITE){bestScore=-Infinity;for(const move of possibleMoves){const piece = currentBoardState[move.start.row][move.start.col]; if(piece.type === PieceType.EMPTY) continue; const tempBoard=applyMoveToBoardCopy(currentBoardState,move);const score=minimax(tempBoard,depth-1,getOpponent(player),-Infinity,Infinity,false);topMovesForDisplay.push({move:move, score:score, piece:piece});if(score>bestScore){bestScore=score;bestMove={...move,piece:piece.clone(),score:score};}}}else{bestScore=Infinity;for(const move of possibleMoves){const piece = currentBoardState[move.start.row][move.start.col]; if(piece.type === PieceType.EMPTY) continue; const tempBoard=applyMoveToBoardCopy(currentBoardState,move);const score=minimax(tempBoard,depth-1,getOpponent(player),-Infinity,Infinity,true);topMovesForDisplay.push({move:move, score:score, piece:piece});if(score<bestScore){bestScore=score;bestMove={...move,piece:piece.clone(),score:score};}}}if(player===PlayerColor.BLACK)topMovesForDisplay.sort((a,b)=>a.score-b.score);else topMovesForDisplay.sort((a,b)=>b.score-a.score);displayTopMoves(topMovesForDisplay.slice(0,3));if(!bestMove&&possibleMoves.length>0){const firstValidMove = possibleMoves[0]; bestMove={...firstValidMove,piece:currentBoardState[firstValidMove.start.row][firstValidMove.start.col].clone(),score:bestScore};}return bestMove;}
        function makeAIMove(){if(isGameOverState||currentPlayer!==PlayerColor.BLACK)return;setMessage("AI calculating...");setTimeout(()=>{if(isGameOverState){isPlayerTurn=(currentPlayer===PlayerColor.WHITE);return;}const bestMove=findBestMoveMinimax(boardLogic,PlayerColor.BLACK,AI_SEARCH_DEPTH);if(bestMove && bestMove.piece){const playerWhoMoved = currentPlayer;makeMoveLogic(bestMove.start.row,bestMove.start.col,bestMove.end.row,bestMove.end.col);refresh3DPieceDisplay();const pieceMovedName=Object.keys(PieceType).find(k=>PieceType[k]===bestMove.piece.type)||"Piece";setMessage(`AI moved ${pieceMovedName}.`);if(isKingInCheck(boardLogic,PlayerColor.WHITE)){playSound(audioCheck);setMessage(`AI moved ${pieceMovedName}. Check!`);}if(isKingCaptured(boardLogic,PlayerColor.WHITE)){setMessage("BLACK WINS!");isGameOverState=true;stopPlayerTimer();stopCurrentMoveTimer();updateDigitalClocks();playSound(audioWin);return;}if(isGameOver(boardLogic,PlayerColor.WHITE)){isGameOverState=true;stopPlayerTimer();stopCurrentMoveTimer();updateDigitalClocks();return;}switchPlayer();if(!isGameOverState){pressClockButton(playerWhoMoved);}}else{setMessage("AI has no valid moves or error.");if(!isGameOver(boardLogic,PlayerColor.BLACK)){isGameOverState=true;}stopPlayerTimer();stopCurrentMoveTimer();}updateDigitalClocks();},700);}
        function displayTopMoves(moves){if(!aiTrainerPanelElement||!topMovesListElement)return;if(moves&&moves.length>0){aiTrainerPanelElement.style.display='block';topMovesListElement.innerHTML='';moves.forEach((m,index)=>{if(!m.piece) return; const pieceName=Object.keys(PieceType).find(k=>PieceType[k]===m.piece.type)||"P";const moveStr=`${pieceName[0]}: ${String.fromCharCode(97+m.move.start.col)}${8-m.move.start.row} -> ${String.fromCharCode(97+m.move.end.col)}${8-m.move.end.row}`;const scoreStr=`(Eval: ${m.score.toFixed(1)})`;topMovesListElement.innerHTML+=`<div>${index+1}. ${moveStr} ${scoreStr}</div>`;});}else{aiTrainerPanelElement.style.display='none';}}

        // --- ANIMATION LOOP ---
        function animateParticles(){if(!particlesPoints||!particlesPoints.geometry||PARTICLE_COUNT===0)return;const positions=particlesPoints.geometry.attributes.position.array;const numParticles=positions.length/3;const particleAnimationSpread=SQUARE_3D_SIZE*BOARD_LOGIC_SIZE*3.0; const particleZResetMax=SQUARE_3D_SIZE*(BOARD_LOGIC_SIZE*0.5+2)+3000; const particleZResetMin=SQUARE_3D_SIZE*(BOARD_LOGIC_SIZE*0.5+2)+200; for(let i=0;i<numParticles;i++){const i3=i*3;positions[i3+0]+=(Math.random()-0.5)*0.06;positions[i3+1]+=(Math.random()-0.5)*0.06;positions[i3+2]+=(Math.random()-0.5)*0.02;if(Math.abs(positions[i3+0])>particleAnimationSpread*1.2)positions[i3+0]*=-0.999;if(Math.abs(positions[i3+1])>particleAnimationSpread*0.7)positions[i3+1]*=-0.999;if(positions[i3+2]>particleZResetMax||positions[i3+2]<particleZResetMin){positions[i3+2]=particleZResetMin+Math.random()*(particleZResetMax-particleZResetMin-100);}}particlesPoints.geometry.attributes.position.needsUpdate=true;}
        function animate(time){requestAnimationFrame(animate);if(particlesPoints) animateParticles();renderer.render(scene,camera);}

        init();
    </script>
</body>
</html>